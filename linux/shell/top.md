# TOP

load average代表CPU的平均负载值，上面示例中的load average: 0.00, 0.03, 0.00分别表示当前CPU在1分钟、5分钟和15分钟内的平均负载。

那么这个值的大小反映系统什么样的一个压力状态呢？这里以单核CPU为例

小于1： 说明平均每次只有不到一个job在忙，对于单核的CPU来说，完全能处理过来

等于1： 说明平均每次刚好有一个job在忙，对于单核的CPU来说，刚好能处理过来

大于1： 说明平均每次有多于一个job在忙，对于单核的CPU来说，由于一次只能处理一个任务，所以肯定有任务在等待，说明系统负载较大，调度不过来，有job需要等待

从上面可以看出，一旦大于1，就说明job得不到及时调度，系统性能将受影响。对于多核来说，由于一次可以调度多个job，所以大于1不一定有问题，以4核CPU为例，该值大于4才说明CPU忙不过来。

那这个平均负载保持在多少比较合适呢？其实没有一个标准值，但一般的做法是预留一定的空间来应对系统负载的波动，建议控制在“0.7*核数”以内，比如4核，那么0.7*4=2.8比较合适，一旦超过这个值，需要分析原因并着手解决。



2.5 us ： 表示CPU有2.5%的时间在运行用户态代码（即在运行用户态程序）

1.8 sy ： 表示CPU有1.8%的时间在运行内核态代码。内核负责管理系统的所有进程和硬件资源，所有的内核代码都运行在内核态，当用户态进程需要访问硬件资源时，如分配内存，读写I/O等，也需要通过系统调用进入内核态运行内核代码。%sy高说明内核占用太多资源，或者用户进程发起了太多的系统调用。

3.1 ni ： 表示CPU有3.1%的时间在运行niceness不为0的进程代码。默认情况下，进程的niceness值都为0，但可以通过命令nice来启动一个进程并指定其niceness值，niceness的取值范围是-20到19，值越小，表示优先级越高，越优先被内核调度。

90.5 id ： 表示CPU有90.5%的时间处于空闲状态

1.7 wa ： 表示CPU有1.7%的时间处于I/O等待状态。通常情况下，当CPU遇到一个I/O操作时，会先触发I/O操作，然后去干别的，等I/O操作完成后，CPU再接着继续工作，但如果这时系统比较空闲，CPU没有别的事情可以做，那么CPU将处于等待状态，这种处于等待状态的时间将会被统计进I/O wait，也就是说CPU处于I/O wait状态即CPU闲着没事干在等I/O操作结束，和idle几乎是一样的。这个值高说明CPU闲且I/O操作多或者I/O操作慢，但低并不能说明没有I/O操作或者I/O操作快，有可能是CPU在忙别的，所以这只是一个参考值，需要和其他的统计项一起来分析。

0.0 hi & 0.4 si ：　这两个值反映了CPU有多少时间花在了中断处理上，hi（hardware interrupts）是硬件中断，si(softirqs)是软件中断。硬件中断一般由I/O设备引起，如网卡、磁盘等，发生硬件中断后，CPU需要立即处理，当硬件中断中需要处理的事情很多时，内核会生成相应的软中断，然后将耗时且不需要立即处理完成的操作放在软中断中执行，比如当网卡收到网络包时，需要CPU立即把数据拷贝到内存中去，因为网卡自带的缓存较小，如果不及时处理的话后面的数据包就进不来，导致丢包，当数据拷贝到内存中之后，就不需要那么着急的处理了，这时候可以将处理数据包（协议栈）的代码放在软中断中执行。本人不是内核专家，关于软中断的部分请参考Understanding the Linux Kernel, 3rd Edition

0.0 st　： %st和虚拟机有关，当系统运行在虚拟机中时，当前虚拟机就会和宿主机以及其它的虚拟机共享CPU，%st就表示当前虚拟机在等待CPU为它服务的时间。该值越大，表示物理CPU被宿主机和其它虚拟机占用的时间越长，导致当前虚拟机得不到充足的CPU资源。如果%st长时间大于0，说明CPU资源得不到满足，这时可以考虑将虚拟机移到其它机器上，或者减少当前机器运行的虚拟机数量。

